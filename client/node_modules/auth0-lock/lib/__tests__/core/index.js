'use strict';

var _immutable = require('immutable');

var _immutable2 = _interopRequireDefault(_immutable);

var _data_utils = require('../../utils/data_utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var setResolvedConnection = function setResolvedConnection() {
  var _require;

  return (_require = require('core/index')).setResolvedConnection.apply(_require, arguments);
};

var mockLock = 'm';
var mockSet = void 0;
jest.mock('utils/data_utils', function () {
  return {
    dataFns: function dataFns() {
      return {
        set: mockSet
      };
    }
  };
});

describe('setResolvedConnection', function () {
  beforeEach(function () {
    mockSet = jest.fn();
    jest.resetModules();
  });
  it('sets undefined when is called with undefined', function () {
    setResolvedConnection(mockLock, undefined);
    expect(mockSet.mock.calls.length).toBe(1);
    expect(mockSet.mock.calls[0]).toMatchSnapshot();
  });
  it('validates format', function () {
    expect(function () {
      return setResolvedConnection(mockLock, {});
    }).toThrowErrorMatchingSnapshot();
    expect(function () {
      return setResolvedConnection(mockLock, { type: 'foo' });
    }).toThrowErrorMatchingSnapshot();
    expect(function () {
      return setResolvedConnection(mockLock, { name: 'bar' });
    }).toThrowErrorMatchingSnapshot();
  });
  it('accepts only database connections', function () {
    expect(function () {
      return setResolvedConnection(mockLock, { type: 'foo', name: 'bar' });
    }).toThrowErrorMatchingSnapshot();
  });
  it('sets the connection', function () {
    setResolvedConnection(mockLock, { type: 'database', name: 'bar' });
    expect(mockSet.mock.calls.length).toBe(1);
    expect(mockSet.mock.calls[0]).toMatchSnapshot();
  });
  it('sets the connection as a Map instance', function () {
    setResolvedConnection(mockLock, { type: 'database', name: 'bar' });
    expect(mockSet.mock.calls.length).toBe(1);
    expect(_immutable2.default.Map.isMap(mockSet.mock.calls[0][2])).toBe(true);
  });
});
